certain // adj. 确定的；某些
```go
absence // n. 缺席；缺乏
inject // v. 注射；注入
primarily	 // adv. 主要地；起初地；
delimiter  // n. 分界符；分隔符
communicate // v. 传达；沟通
significant // adj. 重要的；有意义的
optimal // adj. 最理想的；最佳的
briefly	// adv. 简短地；简单的
denote // vt. 表示； 象征
exhausted // adj. 用完的；筋疲力尽的
fundamental	// adj. 基本的；根本的；重要的
compromise // n.折衷
// B-Trees represent a fundamental compromise between cache-efficiency and actually minimizing the amount of work performed in a search.
// B-树代表了在缓存效率和实际最小化搜索过程中执行的工作量之间的一种基本折衷。
spawn   // 产生；造成
// spawn a process
in order to  // 为了
consecutive	// adj. 连续的；连贯的
hint  // n. 暗示  v. 示意  
idiomtic // adj. 符合语言习惯的; 地道的
overflow // v. 淹没；使泛滥  n. 溢流
establish // v. 建立；确立
slightly	// adv. 稍微
boilerplate // n. 样板文件
introduce  // vt. 介绍，引进
manual	// adj. 手工的
intergrate // v. 整合；结合； adj. 完整的；组合的
leverage // v. 补充
transient // adj. 短暂的； 
diminish	// vt. 减少；减损 vi. 变少
pragmatic // adj 实际的
intent	// adj. 热切的；专心的；决心的  n. 意图;目的
customize  // vt. 定制
refer to // 涉及；指的是；提及；参考
respective // 分别的；各自的
// please refer to the respective documentation for details.
// 请参考相应的文档以获取详细信息
opaque // adj. 不透明的；难懂的
integration // n. 集成；综合
// third party integrations 第三方集成包
appropriate  // adj.适当的
capable		// 有能力的；能干的；
alteration // n. 改变；变更
formally	// adv. 正式的；形式上的
noteworthy //adj.值得注意的
semantic //adj. 语义的
overlap // vt. 重叠；vi. 有重叠部分 n.重叠部分
inadvertently	// adv. 不注意地；疏忽地
strategy	// n. 策略；战略
alleviate	// vt. 减轻；使。。缓和
achieve	// v. 完成；达到；实现
tend to // v. 倾向；导致
sequentially	// adv. 顺序地；继续地
segment		// n.部分
cooperate  // vi. 合作；协力；配合
reconcile	// v.调和；和解
diverge		// v. 分歧；分叉
divergent  // 分歧的；分开的；偏离的
variant	// n.变体 adj.不同的
verbosity	// n. 冗长
distract // vt. 分散；转移
// the film managed to distract me from these problems for a while.
collapse // v. 倒塌；奔溃；瓦解
recursive	// adj.递归的；循环的
reflexivity	// n. 自反性；反身性
techninal	// adj. 技术的；专业的；工艺的
dereference // v. 解引用
trivial	 // adj. 不重要的；琐碎的
explicitly	// adv. 明白地；明确地
particular // adj. 特定的；专指的；特殊的；特别的 n. 详情；细节
// n. 详情；细节
desire	// n. 渴望；愿望 v. 渴望；向往
external // adj. 外来的；外部的 n. 外观；外部
multiple //adj. 多种多样的；许多的
encapsulate // v.  压缩；概括 ；封进内部
//by converting undlying error types 
// to own custom error type that encapsulates  
// the underlying error type.
strive // vi. 奋斗；努力；斗争
// an implementation of poll should be strive to return quickly.
linger // vi.徘徊；逗留；消磨；漫步
// heap memory will linger forever in an unreachable state.
leak  // v. 漏，泄漏 n.漏洞；泄漏
dispose // v. 消除；处理掉；解决；杀死
encompass // vt. 围绕；包围；包括；完成
// The prison is encompassed by high walls.
relevant	// adj. 相关的；
subject	// n. 话题
enforce // vt. 强迫；强制；实施；执行；加强
scenarios // n. 情节；情况
technique // n. 技术；技巧；技能
a period of // adj. 一段时间
// this is a scheduling technique where the operating system allows the thread run for a period of time 
preempt	// v. 抢占
// most operating systems implement peemptive multitasking.
temporarily	//adj. 暂时的
analogous	// adj.类似的
// the module provides a `task::yield_now` async function that is analogous to the standard library's `thread::yield_now`
forcibly	// adv. 强行地；强烈地
detach	// vt. 脱离；分离
deny		// vt. 拒绝
authentication // 认证
authorization // 授权
cyan	// n. 蓝绿色
alternatively // adv. 二者择一地；作为选择
optimally	//adv. 最佳地
instantly	// adv. 立即地；即刻地
a series of // 一系列；一连串
perform //v. 执行
// Iterators alse provide a series of adapter methods for performing
// common threads to sequences
annotation // n. 注解；评注
infer // vt. 推断；猜测；vi. 作出推论
facilitate	// vt. 促进；帮助
indice		// n.标记
fulfill 	//vt. 完成；履行；执行
convert 	// v 转化；转变
tokenization	// 标记化
furthor	// adj.更远的； adv.进一步地；此外； v.促进；推动
derivative //n. 派生物； adj.派生的
abstraction	// n. 抽象；抽象概念
measurement //n. 测量，尺寸
leap //v. 跳跃 n.跳跃
inherit	// v. 继承；遗传
precise // adj. 精确的；恰好的；准确的；严格的
notion // n. 观念；概念；想法；主张
assignment // n. 分配；任务；功课
in the sense // 就...而言
placement // 位置
self-referential // 自述
subtle	// adj. 微妙的；
discuss	// v. 讨论
solely	// adv. 独自地；单独地
identically	// adv. 同一地；相等地
lightweight	 // 轻量级
ergonomic	// 人体工程学
intermediate // 中间体
invocation // 调用
fence // 栏栅
prime	// 最典型的
subtle	// 微妙；微妙的
convention // n. 约定
a broad sense // 广义上；泛指
drawback	// n. 缺点；
constrain	// 强迫；限制
enclose // v. 封装
influence // v. 对..产生影响
normalize //v. 规范
metioned // adj. 所提及的
metion //n. 概念
convention	// n. 公约
manifest // n. 表现 v.
registry	//n. 注册处，注册中心
alternative	// n. 替代品
dig	//v. 挖掘
a bunch of // 一堆
bunch // 串
revision // n. 修订；调整
exact	// adj. 精确的
breakage // n. 破损
redundant //adj. 冗余
architecture	// n. 架构；建筑
subdirectory	// n. 子目录
incremental  // adj. 递增的
artifact // n. 工具
benchmark	// n. 基准
individual	// adj. 单独的
deduce  // v. 推导
coordinate // v. 统筹
mutually	// adv. 相互
identifier	// n. 标识符
punctuation	// n. 标点符号
individual	// adj. 单独的
navigation // n. 导航
ambiguity 	// n. 模糊；歧义
reasonably	// adv. 相当地
repeatition 	// n. 重复
gracefully  // adj. 优雅地
aggregate	// n. 汇总;聚合；adj.总计的；
utility	// adj.n. 实用的 实用
algorithms // n. 算法
essential	// adj. 本质的；必要的；重要的；n.要素；必需品
opportunity	// n. 机会
complex	// adj. 复杂的
terminology	// n. 词汇；用例;术语
organization	// n. 组织；机构；团体
isolation	// n. 孤立，隔离
separately	// adv. 分别地
pinpoint // n. 针对
debate	// v. 讨论
ancestor  // n. 祖先
coverage  // v. 覆盖 n.覆盖率
alphabet  // n. 字母，字母表
unaligned  // n.未对齐
coerce // v. 强制，威胁
clarity // n. 清晰；清晰度；明确性
literally	// adv. 字面上；按字面上的
evaluation	// n. 评价，评估
calculate // v. 计算；估计；
byte-wise // n. 按字节计算
reach	// v. 达到
verbose // adj. 冗长
flavor	// n. 风味
occasion	// n. 时机
toggle	// v. 切换
indent	// v. 缩进
panel	// n.面板
interact	// v. 互动，交互
toss	// v. 折腾，抛出
statically	// adv. 静态地
contract // n. 契约
uphold	//v. 支持
rigorously	// adv. 严禁地
boils down	// 归结为
soundness // n.健全性
asymmetric // adj. 非对称的；
symmetric //adj. 对称的
inherently	// adv. 本质上
differentiate // 区分
// differentiate	between
make sense for ... // 对。。有意义
sloppy // adj. 马虎
shift	// v. 调迁； 移
obey	// v. 遵守
misuse	// v. 滥用;误用
significantly // adv. 大大地；显著地
complicated // adj. 复杂的
sound	// adj. 健全的
trivial	// adj. 小的
omit	// v. 省略
validity	// n. 有效性
separate // adj. 单独的
canonical	// adj. 典型的
synchronize	// 同步
volatile // n. 易变
interleaved // adj. 间隔的
determined	// adj. 定出；确定的
eventually	// adv. 最终地
axiom	// n. 公理
arithmetic	// n. 运算
// pointer arithmetic 指针运算
alignment	// n. 对齐
proper // adj. 正确的
strict // adj. 严格的
provenance	// n. 出处；溯源
experimantal	// adj. 实验性
notably	//adv. 尤其是
insufficiently	// adv. 不够地
extramely	// adv. 极度地
interpretation	// n. 解释；翻译
messy // adj. 杂乱
partial	// adj. 局部 n. 部分；局部
logic	// adj. n . 逻辑；推理
pervasive	// adj. 普遍的；渗透的；
property	// n. 性质；属性
significantly	// adv. 意味深长地；重要地；较大地
foremost	// adj 最重要的；最初; adv. 在最前面
marginal // adj. 边际的；末端的；微小的
unreachability // adj. 不能到达的
infalliable // adj.不能到达的；不能得到的
unwrap // adj. 打开，展开 
principle // n. 原理；原则；信念
transmute  // v. 使。。。变形
transparent // adj. 透明的；清晰的
abort // v. 中止
sanitize // vt. 消毒；使无害
positive  // adj. 积极的；肯定的；明确的 n. 正面	
stand for  // 代表
exception // n. 例外；不合规则
consistent // adj. 始终如一的；持续的；一致的
scene // n. 情景；场；景
fold  // v. 包，折叠，交叉，拥抱 n. 折叠；折痕
assumption  // n. 假定；设想；假装
nondeterministic // adj. 非确定的
issue // n. 议题；问题； v. 发表；公布
hoist // v. 升起；升高
prefetch // v. 预取
fetch // v. 取来； n.取得
superscalar // n. 超标量
reorder // v. 重新排序；重新布置
hardware // n. 硬件
error-prone // 易出错
prone // adj. 易于...的, 有...倾向的
prolong // v. 延长；拖延
mechanism // n. 机制；原理；结构
ordinary // adj. 平凡的；普通的；平淡的
flexibility // n. 灵活性；弹性
outstanding // adj. 优秀的；突出的；未支付的；未完成的
demonstrate // vt. 证明；演示；示范； vi. 示威
transmute // v. 使...变形
trivially // adv. 琐细的；无能地；平凡地
imporper  // adj. 不合适的；错误的；不道德的
coerce // vt. 强制；威胁
inspire // v. 鼓舞；激发；产生；赋予...灵感
hint  // n. 暗示; v. 暗示；示意
tier // n. 排，行，层， 等级 v.层层排列
intrinsic  // adj. 内在的；固有的；本质的
upstream  // adj. 上游的 adv.向上游地
nor  // conj. 也不；，也没有 adj.
foundation // n. 根基；基础；根据
statement // n. 陈述；声明
casually // adv. 偶然地；随便地；随意地；
peruse // v. 阅读
prose // adj. 散文的; n. 散文
distract // v. 分散；转移；分心
peek  // v. 偷看;窥视 n. 偷看
divide // v. 划分；隔开；分割
portable // adj. 轻便的；手提式的
pervasive // adj.普遍的；渗透的；遍布的
coercion  // n. 强迫
contribute // v. 捐助；投稿； 
mindful	// adj. 深切注意的；记住的
inclusive // adj. 包含...在内的; 
stopgap // n. 权宜之计
breakout // n. 突破
massive // adj. 巨大的；大量的
complicate // adj. 复杂的； v. 使复杂化；
dangling // n. 悬挂；悬空。 
naive	// adj. 天真的；幼稚的
freeze // v. 凝固；冻结； n. 冻结；
caveat // n. 防止误解的说明;警告
sake // n. 理由；缘故；目的；利益
interrupt	// v. 打断；打扰；中断； n.中断
liberal // adj. 慷慨的；大方的；开明的； n. 自由主义者；开明的人
region // n. 地区；地域
interprete // v. 解释
multiplexed	// adj. 多路复用的；多路的
intermixed	// v. 混合；混杂
instrument // n. 工具  v. 装备
bundle
aggressive // adj. 侵略的；积极的
majority	// n. 多数；大多数
// the majority of 大多数；绝大多数
snippet // n. 小碎片；片段；摘录
explicitly // adv. 显式地；清楚地；
implicitly	// adv. 隐式地；
circumstance	// n. 情况；条件
coercion	// n. 强制
far-reaching	// adj. 影响深远的
implication // n. 含义
silently	// 默默地；静默地
facilitate	// v. 促进
inherent	// adj. 固有的;内在的
workload	// n. 工作量
mature  // adj. 成熟的；考虑周到的； v. 成熟；长成
constraint // n. 限制
mixture	// n. 混合;
novel // adj. 新奇的
firm // adj.adv 坚定的；稳固的；结实的
partial // adj.不完全的；部分的
latency // n. 潜伏；潜伏期；延迟
critical // adj. 临界的
edge // n. 边缘；优势
invalidate	// 使无效；使作废
iterate	// v. 反复说；重做； 迭代
reiterate	// vt. 重申
solely	// adv. 独自地；单独地；完全
pattern // n. 模式；方式； v.仿照；模仿
respect to ... and ... // 就 ... 和 ... 而言
erase	// v. 抹去；擦掉(计算机)；消除
nevertheless	// adv. 尽管如此；仍然；不过
marker //n. 标识；标志
ultimately //adv. 最后；最终
fusion	// n. 联合；合并;融合
propose // v. 打算；计划；提出
proposed // adj. 被提议的
nonce	// adj. n. 临时；暂时；只用一次的
evolution	// n. 进化；发展；演变
pure	// adj. 纯的；纯粹的
parallel	// adj. 平行的；相同的；
// n. 对比；平行； vt. 相比；相应
migration	// n. 移动；移往
compact // adj. 紧密的；紧凑的；简洁的
expanded // 可扩展的
respectively	// adj. 分别地；各自的
demand	// n. 要求；需求 v. 要求；查问；需要
preferable	// adj. 更好的；更合意的
bandwidth // n. 带宽
dive to // 深入研究
introduce // v. 介绍；引进；提倡；采用
concern // n. 关心  vt.涉及，影响
inadvertently // adv. 不注意地；疏忽地
alleviate // 减轻；使... 缓和
fulfill	// vt. 完成；履行
facility	// n. 机制；设备；才能
transition	// n. 转变；过渡
directive // n. 指令 adj.指导的；指挥的
distend // v.  擴大；擴張；吹大；膨脹
geared toward	// 面向
entry points // 切入点
procedural	// 程序的
complete	// adj. 完整的；完成的
attach	 // v. 附上；使依附；
inverse  // adj. 倒转的；相反的； n. 倒数；相反的事物
transaction // n. 交易
indepentent // adj. 独立的；自主的；独自的
vulnerable  // adj. 有弱点的；脆弱的
consensus  // n. 一致；共识
distinction // n. 差别；对比
contrast  // n. 对比；差别； v. 对比
rotation // n. 旋转；循环
ledger  // n. 明细账
decentralize  // v. 分散
cryptocurrency  // n. 加密货币
encounter  // n. 遭遇； v. 遭遇
trade // 贸易
cryptography // n. 密码术；密码系统
centralize  // v. 聚集；集中
meanwhile  // adv. 于此同时; 同时
agreement // 同意；一致；协议
transport // n. 运输； v. 运输；传播
transform // vt. 改变；转换；vi. 改变；变形
transfer // v. 转移；n. 移动
contrary // adj. 相反的；截然不同的； n. 反面；相反
slight // adj. 轻微的；微小的； vt. 轻视；忽略； n. 轻蔑；怠慢
parallelism // n. 平行；相识; 并行
alternate // v. 交替；轮流。adj. 间隔的；轮流的；交替的； n. 替代者
dedicate // v. 致力于
dedicated // adj. 专用的
flaw  // n. 瑕疵；缺陷； v.使破裂
approach // v. 靠近；接近；达到  n. 途径；方法
qualify // vt. 使具备资格； 描述； 修饰  vi. 取得资格；合格
misconception // n. 误解；错误想法
struggle  // vi.n. 努力；斗争
phrase  // n. 短语；
interwine // v. 纠缠；缠绕
despite  // prep. 尽管；不管； n. 憎恨；轻视
hardcode // 写死
further // adj. 更远的；进一步地；此外
reinforced  // adj. 加强的;
reinforce  // vt. 加固；加强；增强; vi. 得到加强
purely  // adv. 纯粹地；清白地；纯洁的;
illustrative // adj. 说明的
singleton  // n. 独生子；单身
conciseness // n. 简洁；简明
consequence  // n. 结果；后果；重要性；影响
permanently // adv. 永久地；
suspend // v. 暂停；悬浮；中止
efficient  // adj. 效率高的；胜任的
sufficient // adj. 足够的;充分的
persisted  // v. 坚持；执意；继续；持续
mass // n. 大量；众多； adj. 大规模的；群众的; v. 集中
adoption // n. 采用；采纳；收养
utilize  // 利用
interoperable // adj. 彼此协作的
flaw  // n.v 瑕疵；缺陷；使破裂
instantiate // v. 示例。说明
whenever // adv. 无论何时； conj.每当
steal // v. 偷；窃取；n. 窃取
sophisticated // adj. 老练的；精密的；复杂的；
corollary	// n. 推论
conversely	// adv. 相反的
resume  // v. 重新开始；再继续； n.简历；摘要
neither  // pronv. adj. 两者都不； adv.conj. 也不
couple  // n. 对；数个 v.连接；交配
guard // v. 看守；守卫；保卫； n. 哨兵；警卫
robust // adj. 强健的；稳固的；耐用的
shallow // adj. 浅的； n. 浅处； v.变浅
roughly // adv. 粗略地； 大约；
capability	// n. 才能；能力；性能；容量
capacity	// n. 容量；容积；能力；职位；资格·
cotention  // n. 争论；争辩
contend  // v. 竞争；斗争；争辩
handful  // n. 一把；少数
distinct  // adj. 明显的；清晰的；不同的
identify  // vt. 鉴定；识别；辨认出； vi. 认同；
outline  // n. 大纲；轮廓； vt. 概述；
transmit // vt. 传达；传染；传送
computation  // n. 计算；估计
rather // adv. 相当；有点儿；相反
somehow // adv. 以某种方式； 不知怎么地
as longs as // 只要；和...一样长
phantom // n. 幻影； adj. 错觉的；
in-depth // adj. 深入的；彻底的；
approximately	// adv. 大约；近似地
simulate // vt. 假装；模拟；模仿
deem // v. 认为；视作
nope // adv. 不
conclude // vt. 推断出； vi. 结束；总结
mutual // adj. 共同的；相互的
anonymous	// adj. 匿名的；无名的；没特色的
appropriate	// adj. 
combat  // n.v. 试图解决；于...斗争 adj. 战斗的
as well as // 也；还；和...一样
fatal // adj. 致命的；毁灭性的；决定性的
preserve // v. 保护；保存；保持； 
innovation // n. 创新；革新
placeholder // n. 位置标志符； 占位符
transmission // n.传输；传播；播送；
interconnect // v. 使互相连接；连接
promote // vt. 促进；提升；发起
datagram // n. 数据包；数据报
interconnect // v. 使互相连接；连接
destination	// n. 目的地；终点
conversion // n. 转变；换算
blanket // adj.包含所有的；适用于所有情形的
facet // n. 小平面；方面
express // v.表示；表达
merely // adv. 仅仅；只不过
purpose // n. 目的；决心
broadly // adv. 概括地；大体上
rapid // adj. 短时间发生的；急速的；迅速的 n.急流；湍急
reinterpret // vt. 重新解释
bitwise	// n. 逐位；按位
downcase // adj.向下看的
fragmentation // n. 分裂；破碎；
shrink // vi.vt.n 收缩；退缩；萎缩
deque	// n. 双端队列
division // n.划分；除法
predicate // n. 谓语；adj.谓语的
negative	// adj. 负的；消极的
transpose // vt.n 调换，颠倒顺序
swap // vt.n 交换
lookup // n. 检查；查找；查询；搜索
permissible // adj. 可允许的；容许的
either...or... // 要么...要么
deprecated // adj. 丢弃的
in the sense that // 在某种意义上说
more generally	// adv. 更普遍地说
// in generally: 用于引出普遍的概括，适用于大多数情况，但不一定是全部情况
// more generally: 用于从一个具体的例子引出一个更广泛的概括，表示在更宽泛的范围内适用。
satisfy	// v. 使满意；满足；使信服
in that // 因为；由于；既然
lifespan	// n. 寿命；使用期限
pinboard // n. 插线板；面板
incredibly	// adv. 极其；难以置信地；
reason about // 推出
instrusive // adj. 侵入的
model // adj. 模范的；v. 做模型；模仿；塑造
guarantee // n. 保证；担保 vt. 保证；担保
rely	 // vi. 依靠；信任
remain // v. 保持 n. 遗迹
as though // conj. 彷佛；好像
sensitive	// adj. 敏感的； n. 敏感的人
target // n. 目标 vt. 把...作为目标
first off //  首先；起先；开始时
factor // n. 因素； vt. 把...考虑包括进去 vi. 作为因素
governance // n. 统治；支配；管理
inflation // n. 通货膨胀；膨胀
backed by // 在... 的支持下
fairly	// adv. 公正地；相当地；
cooperatively // adj. 合作的；协作的 n. 合作社
multitasking // n. 多任务处理
preempt // v. 抢占
starve // vi. vt. 使挨饿；
collaborate // vi. 合作；
sequential // adj. 连续的；顺序的
notation // n. 记号；表示法；注释；记法
lexer // n. 词法分析器
unary // adj. 一元的；单项的
binary // adj. 二元的
phase // n. 阶段；相位；状态；adj.阶段性的
feed // v. 喂养；进餐；n. 饲料
monospace // n. 单间隔；单一间隔
grammer // n. 词汇
capital // adj. 大写的
italic // adj. 斜体的
suffix // 后嘴
intervene // vi. 干预；干涉；介入；调停；插入
vertical // adj. 垂直的；纵向的； n. 垂直物，垂直的位置。
align // vt. 成一条线
rotate // v. 轮流；旋转; adj. 车轮装
in particular // 尤其
bundle // n.捆；束；包 v. 捆；把...扎成一捆
interoperability	// n.互操作性；互用性
dimensional // adj. 纬度的；次元的；空间的
rapidly	// adv. 迅速地；很快的
extension // n. 延长；伸展；延期
treat // v. 对待；视为
unversed // adj. 不熟练的；不熟知的；无经验的
apart // adj. 分开的；分离的
apart from // 除...以外；且不说
conservative // adj. 保守的；守旧的
intersection // n. 交集；交叉
signal // v. 表示；n. 信号； adj. 显著的
corresponding // adj. 相当的；相应的；一致的
subsequent // adj. 随后的；后来的；
by convention // 按照惯例
ones // n. 其中之一
ditto // n. 同上
playback // n. 回放；重放
mute  // adj. 无声的
natural // adj. 自然的；天然的
negation // n. 对立面；否定；反对
predicate // n. 谓语；术语； v. 断定；意味着；adj. 谓语的
resolve // v. 解决；决定 n.决心
subscribe // vt. 订阅；签名；支持；捐赠；同意
noop // n. 无操作
conjunction // n. 结合；关联；同时发生
cascade // n. 瀑布；瀑布似的留下
perferred // adj. 首选的；有优先权的
precede // vt. 在...前面；先于； vi. 在前面；领先
constraints // n. 强制；被约束；拘束
responsibility // n. 责任；职责
duplicate // n.副本； v. 复制； adj. 完全一样的；复制的
generalize // v.概括；归纳；使一般化
claim // n. 要求；要求权；主张； vt.要求；请求；主张
hybrid // n.混合物
typically // adv. 典型地；代表性的；通常；一般；不出所料的
occasionally // adv. 偶尔的
under the hook // 内部机制；底层原理
logically // adv. 符合逻辑的；逻辑上地
ultimately // adv. 最终；最后
sentinel // n. 哨兵； 标记符号
well-aligned // 有序排列
presumably // adv. 大概；可能
intention // n. 意图；目的；意向;打算
access // n. 入口；通道；n.接近；使用之权
characteristic // n. 特点；特性；特色； adj. 典型的；特有的
motivation // n. 动机；动力；刺激；积极性
disrupt // vt. 干扰；打断；妨碍
steady // adj. 稳定的；稳固的；坚定的； v. 使稳固；
inflow // n. 流入；流入量；
speed up // 加快速度
threshold // n. 门槛；开端；界限；入口
on the other hand // 另一方面
bason on // 基于；以...为依据
plain  // adj. 清楚的；简单的；坦白的；纯的  adv.完全的；纯粹的
accommodate // v. 适应；调节
vary // v. 改变；变化；使多种多样
upside // n. 优势；潜力
tradeoff // n. 交易；交换
furthermore // adv. 而且；此外
eager // adj. 渴望的；急切的
bloat // vt. 使肿胀；adj. 肿胀的; n. 膨胀
instruction // n. 指令；说明；教诲
vice versa // adv. 反过来也是一样的
erasure // n. 擦掉；抹掉
specialize // v.专供
inhibit // v. 抑制；阻止；使不能
straight-forward // adj. 易懂的；笔直的；坦率的
representation // n. 称述；表现；表示法
progessive // adj. 先进的；前进的；渐进的
inference // n. 推理；推断；结论
account for // vt. 对...负责；导致；引起
exceed // vt. 超过；超出；vi.领先
subtly // adv. 敏锐地；巧妙地；精细地；
responsibility // n. 责任；责任心；职责
moticate // vt. 激发；给予动机
biased // adj. 有偏见的；
pseudo // adj. 假的；冒充的
precondition // n. 先决条件；前提； v. 预先准备
device // v. 设计；发明
sequential // adj. 连续的
precision // n. 精确；紧密度 adj. 精确的
decimal // adj. 小数的；十进位的 n. 小数
digit // n. 数字；位数；手指
describe // vt. 描述；说成；形容
correspond // v. 符合；对应；通信
corresponding // adj. 相当的；相应的；一致的
fractional // adj. 微不足道的；短片的；分数的；小数的
especially // adv. 特别；尤其
monetary // adj. 货币的；金融的
subtraction // n. 减法；减去
scale // n. 刻度；等级；规模
up to // 胜任； 直到；多达； 该由...决定
inclusive // adj. 包含...在内的；
physical // adj. 物质的；身体的；物理的
geometric // adj. 几何学的；几何学图形的
appriximation // n. 接近；近似；近似值
retrieve // vt. 恢复；挽回；取回 vi. 找回猎物； n. 恢复；取回；
discrepancy // n. 差异；不一致；分歧
propagate // v. 繁殖；增值；传播；传送
mathematic // adj. 数学的；精确的；可能性很少的
compliate // v. 使复杂化； adj. 复杂的
calculate // v. 计算；估计；考虑；推测；计划；指望
boundary // n. 边界；分界线
underflow // n.潜流；下溢；下线溢位
processor // n. 加工者；处理器
historical // adj. 与历史有关的
reduce // v. 减少；缩小；简化；还原
arrange // vi. 整理；安排；计划； vi. 协商；计划
anticipate // vt. 预期；提前使用；抢...前
currency // n. 货币；流通
bizarre // adj. 奇异的；怪诞的
lack // n.缺乏；无； v.缺乏；不足
in case of // 防备；假如；如果发生
apart from // phr. 缺少；除...之外；且不说
advantage // n. 优势；有利条件；vt.有利于
general // adj. 普遍的；全面的；一般性的；大致的；笼统的；常规的；总的  n. 将军；一般
intend for // 意指；打算
terminate // v. 结束；终止；达到终点
octet // n. 八位位组
escape // n. 转义；
backslash // n. 反斜线符号(\)
fuzz up // v. 使模糊
fuzz // v. 起毛；使变得模糊不清
precede // vt. 在...之间；先于；vi. 在前面；领先
sequence // n. 顺序；连续；次序；一系列 vt. 按顺序排好
confuse // vt. 使困惑；使混乱；混淆
in general // 一般来说
zone // n. 地域；地带；地区
interval // n. 间隔
abbreviation // n. 缩写
plural // adj. 复数的；n.复数
notation // n. 记号；表示法；注释；记法
comprise // vt. 构成；包含
composite // adj. 合成的；复合的 n.合成物；复合材料
optimize // vt. 使完善；使优化
proximity // n. 接近；亲近
rank // n.等级；阶层；排；列  v.排列；分等级；排名
hence // adv. 因此；从此以后
minor // adj. 轻微的；较小的；次要的
constitute // vt. 构成；组成；任命；建立；制定
variation // n. 变种；变动；变化
exploit // vt. 剥削；利用；开发；开拓 n.功绩
multidimensional // adj. 多维的；多面的
dimensional // 纬度的；次元的；空间的
statistical // 统计的；统计学的
consideration // n. 考虑
accordingly // adv. 因此；相应的；于是
estimate // n.v 估计；评价
state // n. 情形；状态；国家；州 v. 称述；说明
assumption // n. 假定；设想；假装
measure // n. 措施；量度；尺寸；程度；方法 v.测量；比较
realize // vt. 实现；了解；意识到；
factor // n.因素；因子； vt. 把...作为因素包括进去; vi. 作为因素
// the determinate factor of our economy is to control inflation. 
// 经济的决定性因素就是控制通胀
govern // v. 统治；支配；管理；规定
phase // vt. 逐步执行；n.相位；方位;局面；阶段
vacant // adj. 空虚的；空的；
occupy // vt. 占用；占领
comprehensive // adj. 全面的；广泛的；综合的
fit into // 适应；符合
compatibility // n. 协调；兼容
inconsistent // adj. 不一致的；
compilation //v. 编辑
automation // n. 自动化
participate // v. 参与；分享
defect // n.缺点；缺陷; v.背叛
cumbersome // adj. 笨重的；不方便的
sensible // adj. 明智的；合情理的；可察觉的；实际的；
universal // adj. 普遍的；通用的； n.通用原理；普遍原则
furturemore // adv. 而且；此外
irrefutable // adj. 不能反驳的；不能回答的；不可否认的
visibility // 能见度；可见性
unified // adj. 统一的
fragment // n. 碎片；片段
nominal // adj. 名义上的；象征性的；名词性的
coherence // n. 一致；连贯
orphan // n. 孤儿； adj. 孤儿的
intersection // n. 交集；十字路口；交叉点
substantial // adj. 大量的；坚固的；实质的 n. 本质；重要部份；实在的东西
// new economic devolepment policies led to substantial and rapid growth.
assume // vt. 假定；假设；设想；承担
intrinsic // adj. 内在的；固有的；本质的
// you have a natural and intrinsic talent and skill 
// 你天生就具有内在的天赋和才能
compose // vt. 创作；编排；形成
consequence // n. 结果；后果；重要性；影响
incredibly // adv. 极其；难以置信的
rare // adj. 罕见的；珍贵的
comprehensive // adj. 全面的；广泛的；综合的；理解的
up to // 直到；多达；该由...决定
contentious // adj. 好辩的；有争议的
contradict // vt. 反驳；与...矛盾
precise // adj. 精确的；恰好的；准确的；严格的
volatile // adj. 不稳定的；反复无常的；易挥发的
obvious // adj. 明显的；显然的
as with ... // 与...一样
curious // adj. 好奇的；奇特的
potential // adj. 潜在的；可能的  n. 潜力；潜能
prove // v. 证明；检验
necessitate // v. 使...成为必须；迫使
in the sense of // 从...意义上说
properly // adv. 适当地；正确的；完全的
proper // adj. 合适的；正当的；真正的
notion // n. 观念；概念；想法；主张
several // pron. 若干；adj. 几个的；若干的；各自的
provenance // n. 出处；起源
uncontroversial // adj. 非争议性的；未引起争论的
retionalise // v. 合理化 
ongoing // adj. 进行的；不断发展的
seek to // 追求；争取；设法
mindful // adj. 深切注意的；记住的
representation // n. 陈述；表现；
conversely // adv. 相反的
apparent // adj. 明显的；表面的;
imposed // v. 强加；强迫；征收；
relax // v. 休息；放松；使放松；放宽
coupled with // 接在一起；耦合；
subsequent // adj. 随后的；后来的；
applicable // adj. 合适的；适用的；可应用的
differ // vi. 不同；有区别
among // prep. 在...之中； ...之一
transformation // n. 转型；转化；改造
sequentially // adv. 顺序地；继续地
extent // n. 长度；宽度；大小；范围；程度
along with // 与...在一起；在...以外；沿着；
first off // 首先；起先；开始时
out of the way // 不寻常地；
broadest // adj. 宽广的；清楚无误的；明显的
sake // n. 理由；缘故；目的；利益
specifically // adv. 特别地；明确地；具体地
devote // vt. 致力于；奉献给；把...专用与
in terms of // 就...而言；在...方面
nonetheless // adv. 尽管如此
rendezvous // n. 约会；汇合点; vi. 汇合；集合
obligate // v. 有负使命；强制；预留 adj.有义务的；必要的；
```

```rust
#[no_exhaustive]: 表示类型或变体将来可能会添加更多字段或者变体。可以应用在结构体，枚举或者枚举变体上。在rust参考手册7.6 类型系统中

声明宏，类函数宏，类属性宏,类派生宏，除了声明宏，其他宏需要创建一个额外的lib.
```

```rust
rust中引用和指针的区别
引用(Reference): 引用是rust中的一种安全指针。它们通过借用检查器来保证安全性，确保在整个生命周期内指向的值都是有效的。
引用分为共享引用(`&T`) 和 可变引用 (`&mut T`)，共享引用允许多个引用同时指向同一个值，但是不允许修改该值，可变引用只允许一个引用指向某个值。

指针(Pointer): 指针是rust中的一种不安全的指针。它们没有生命周期的保证，也不受借用检查器的保护。指针分为 常量指针(`*const T`) 和 可变指针(`*mut T`), 常量指针和可变指针都可以指向任意的内存地址，但是解引用它们是不安全的操作，需要在 unsafe块中进行。
```

```python
原生类型(primitive type) 是编程语言提供的最基础的数据类型。比如字符、整数、浮点数、布尔值、数组、元组、指针、引用、函数、闭包。所有原生类型的大小都是固定的，因此他们可以被分配到栈上。
```

## Fn、FnOnce、FnMut、FnPtr

```rust
// Fn : 
* 表示闭包，可以被多次调用(多次调用意味着它们可以多次被执行，不会消耗闭包的环境)
* 这意味着闭包可以已不可变引用的方式访问其捕获的环境
* 通常用于需要闭包被多次调用的场景

// FnOnce:
* 表示闭包只能被调用一次
* 闭包会move自己捕获的环境，因此闭包之后无法再次使用
* 用于需要将闭包的所有权传递给其他函数或者线程的场景

// FnMut
* 表示闭包可以被多次调用，但是在每次调用之间会修改其捕获的环境
* 意味着闭包可以已可变引用的方式访问其捕获的环境，并且在调用期间对其进行修改
* 用于需要闭包在调用期间修改环境的场景

// FnPtr
* 函数指针类型，表示指向函数的指针
* 不是用于闭包，而是将函数指针作为参数的函数或者方法
* 通过函数指针，可以调用不同的函数，而不需要具体的闭包类型

// 函数指针作为参数
  fn calculate(operation: fn(i32, i32) -> i32, a: i32, b: i32) -> i32 {
      operation(a, b)
  }
// 函数指针作为类型
struct MathOperations {
    add: fn(i32, i32) -> i32,
    subtract: fn(i32, i32) -> i32,
}

```

###### `binary search tree` 二叉搜索树，`balanced binary search tree` 平衡二叉搜索树

```rust
// 二叉搜索树
是一种二叉树数据结构，其中每个节点最多有两个子节点。并且满足以下性质:
1. 节点的左子树中所有的节点的值都小于该节点的值。
2. 节点的右子树中所有的节点的值都大于该节点的值
这些特性使得二叉搜索树中可以进行高效的查找、插入和删除操作，其平均时间复杂度为 `O(logn)`

// 二叉搜索树的节点插入或删除不平衡，可能会导致树的高度，从而降低了其操作的效率。为了解决这个问题，有了 `平衡二叉搜索树`

平衡二叉搜索树是一种特殊的二叉搜索树，它在节点的插入和删除操作后能够自动保持树的平衡，即树的左右子树的高度差不会过大，从而保证了树的高度近似于 `log n`, 保持了操作的高效性。


```

获取rust结构体字段

```rust
macro_rules! struct_names {
    (struct $name:ident { $($fname:ident : $ftype:ty),* }) => {
        #[allow(dead_code)]
        struct $name {
            $($fname : $ftype),*
        }

        impl $name {
            const fn field_names() -> &'static[&'static str] {
                &[$(stringify!($fname)),*]
            }

            const fn struct_name() -> &'static str{
                stringify!($name)
            }
        }
    }
}

struct_names! {
struct Export {
    first_name: String,
    last_name: String,
    gender: String,
    date_of_birth: String,
    address: String
}
}
```

`pub(crate)` 和 `pub(super)`区别

```rust
pub(crate) -> 表示公开项(module, struct, enum, trait, function)等可以在当前crate的任何对方访问，但是在 crate外部是不可见的。将项限定在了当前crate内部。

pub(super) -> 表示公开项可以被其父模块(或者更高层次的父模块)及子模块访问，但是对于crate外部不可见。他将项限定在了当前的父模块内部
```

### `T: 'static` 和 `&'static`的区别

&'static T 是对某个 T 的**不可变引用**，可以安全地无限期保存，包括直到程序结束。这只有在 T 本身不可变，并且在创建引用后不会移动的情况下才有可能。T 不需要在编译时创建。可以在运行时生成随机的动态分配数据，并通过内存泄漏返回 "静态引用"，例如

```rust
use rand;

// generate random 'static str refs at run-time
fn rand_str_generator() -> &'static str{
  let rand_string = rand::random::<u64>().to_string();
  Box::leak(rand_string.into_boxed_str())
}
// or:
static MY_DATA: i32 = 10;

fn main(){
  let reference: &'static i32 = &MY_DATA;
  ...
}
```

T："static "是一些可以安全地无限期保存的 T，包括直到程序结束。T：'static 包括所有 &'static T，但也包括所有所有者类型，如 String、Vec 等。只要某些数据的所有者持有这些数据，就能保证这些数据永远不会失效，因此所有者可以安全地无限期地持有这些数据，包括直到程序结束。T：'static'应理解为 "T 以'static lifetime'为界"的范型约束，而不是 "T 有'static lifetime'"。用一个程序来说明这些概念：

```rust
use rand;

fn drop_static<T: 'static>(t: T) {
    std::mem::drop(t);
}

fn main() {
    let mut strings: Vec<String> = Vec::new();
    for _ in 0..10 {
        if rand::random() {
            // all the strins are randomly generated
            // and dynamically allocated at run-time
            let string = rand::random::<u64>().to_string();
            strings.push(string);
        }
    }

    // strings are owned  types so they're bounded by 'static
    for mut string in strings {
        string.push_str("a mutation");
        drop_static(string);
    }

    println!("I am the end of the program");
}

```

### `String` 和 `str`的区别

`String` 表示 堆上分配的可变长度的 `UTF-8`编码的字符串，拥有所有权的类型，它在堆上分配了一段内存来存储字符串数据，并负责在作用域结束时释放该内存。这意味着 `String`的类型的变量可以在不同的作用域中移动而不是赋值。

`str` 是一个不可变的字符串切片类型，它指向一段 `UTF-8`编码的字符序列，常用于对已有字符串数据的引用。

### `切片(slice)`, `迭代器(iterable)`, `向量(vector)`, 数组(Array)之间的区别

* 数组是具有固定长度，固定类型的数据结构，数组在编译时必须知道其长度，长度不可变；类型是 `[T;N]`，`T`是类型，`N`是长度；在栈上分配用于较小的数据集
* 切片是对数组、vector等其他数据类型的引用；切片不拥有数据，只是拥有对数据的引用；切片的数据类型是`&[T]`,T是元素的类型；切片可以动态的指向数据的不同部分，而不需要复制数据；切片允许对数据进行访问和操作，但是不能改变长度。
* 迭代器:迭代器是一种对集合元素逐个访问的接口；迭代器可以用于数组，vector，切片等类型，迭代器通常用于函数式编程，可以方便的对数据进行处理和转换; 迭代器提供了各种方法: map,filter,fold
* Vector: 是一种动态数组的数据结构；长度是可变的可以动态的添加和删除元素；向量的类型是 `Vec<T>`,其中`T`是向量中的元素类型；向量在堆中分配内存，可以存储不同长度的数据；并且支持动态的调整大小；

**它们之间如何转换**

```rust
// 数组 => 切片
let array: [i32; 5] = [1,2,3,4,5];
let slice: &[i32] = &array;

// 切片 => 向量
let slice: &[i32] = &[1,2,3,4,5];
let vector: Vec<i32> = slice.to_vec();

// 向量 => 切片
let vector = vec![1,2,3];
let slice: &[i32] = &vector[..];

// 向量 => 数组
let vector = vec![1,2,3];
let array_slice: &[i32] = &vector[..];
let array: [i32;3] = array_slice.try_into().unwrap(); // or into

// 数组 => 向量
to_vec()
// 向量 => 迭代器
iter()
// 切片 => 迭代器
iter()
// 迭代器 => 向量
collect()
```

### `IntoIter`和 `Iterator`的区别

`Iterator`是一个`trait`,定义了迭代器的行为，表示可迭代的核心概念。提供了如 `filter()`, `map()`, `collect`等方法，允许对序列进行各种操作。

`into_iter()`是一个方法，用于将所有权转移到迭代器；意味着它将原始的所有权转移到一个迭代器，使得原始集合在迭代过程中无法访问。`into_iter()`会产生一个迭代器，该迭代器会消耗原始集合的所有权，常用于需要消耗集合的场景，比如在使用完集合后不需要原始集合。

### `Unpin`和 `Pin`

`Unpin` trait表示类型是非固定的，也就是说，它们可以自由地移动到内存中的其他位置而不会影响安全性。默认情况下，rust中的类型是可移动的，也就是它们实现了 `Unpin` trait，这意味着它们可以在`Future`和 `Stream`中自由地移动，而不需要特殊处理。如果一个类型实现了 `Unpin` trait, 它就不会被固定到内存中的特定位置。

Pin表示一个智能指针，用于指示类型被固定，即不能在内存中移动。

### protobuf的模版

```protobuf
syntax = "proto3";

option java_multiple_files = true; // 是否生成多个java的源文件，当设置为true时，每个消息会生成单独的java文件，方便组织和管理。
option java_package = "io.grpc.examples.routeguide";  // 指定了包名，指定了java代码应该位于 `io.grpc.examples.routeguide`包中
option java_outer_classname = "RouteGuideProto"; // 指定了生成的java代码的顶层类为 `RouteGuideProto`
package routeguide; // 定义了消息的命名空间。即消息类型的前缀；
```

### 什么是 ttl，tsl，ssl

`TTL`(Time To Live),` TSL`(Transport Layer Security),以及 `SSL`(Secure Sockets Layer)

#### TTl

网络通信中的一个概念，它表示数据包在网络中能够存活的时间。在IP协议中，每个数据包都会被分配一个TTL值，表示数据包在网络中能够经过多少路由或者交换机。当一个数据包经过一个网络设备时，TTL值会递减，直到减为0为止，此时数据包会被丢弃。TTL主要用于防止数据包在网络中无限循环，同时也可以用于网络拓扑的调整和故障排除。

TSL 和 SSL

网络通信加密协议，建立在传输层之上，TSL是SSL的升级



### arcwrap=> 原子性的arc修饰，用于多线程环境下处理数据

### 位运算

```rust
let a = 0b0011;
let b = 0b1100;

// &: 与运算；对应位置上的两个位都为1时，结果为1，否则为0；
assert_eq!(a & b, ob00);
// |: 或运算；对应位置上的两个位只要有一个为1，结果就为1；
assert_eq!(a | b, 0b1111);
// ^: 异或运算；对应位置上的两个位相同的结果为0，否则就为1；
assert_eq!(a ^ b, 0b1111);
// <<: 左移；左移操作符，将二进制数向左移动指定的位数。在左移过程中，从右边开始的位数被丢弃，左边空出的位会用0填充；通常用于将一个数乘以2的幂次方。
assert_eq!(a << 3, 0b11000);
// >>: 右移: 右移操作符；将二进制向右移动指定的位数；在右移过程中，左边开始移出的位置被丢弃，右边空出的位置会用0填充。右移操作通常将一个数除以2的幂次方
let c = a >> 3;
assert_eq!(c, 0b01);
```

### 可变借用和不可变借用

* 一个资源内智能有一个可变借用。
* 拥有可变借用后就不能有不可变借用
* 一个资源内可以有多个不可变借用，但拥有不可变借用后就不能有可变借用。

### 为什么官方推荐使用`Vec`或者 `VecQeque`,而不是链表

因为使用基于数组的容器(Vec或者 VecDeque)通常比基于链表的容器(如`LinkedList`)更快、更内存高效，并更好利用CPU缓存的原因有几个:

* **内存连续性**；基于数组的容器在内存中存储元素是连续的。访问数组元素时CPU可以有效地预取相邻元素到高速缓存中。相比之下，链表的节点在内存中是离散存储的，这可能导致在访问链表中的连续元素时，频繁的缓存未命中，从而降低性能。
* **空间开销**：数组通常比链表更节省内存，因为数组只需要额外的空间来存储元素本身，而链表还需要额外的指针来连接节点。在大多数情况下，数组存储元素所需要的内存开销更小，尤其是当存储大量小型对象时。
* **局部性**：对于基于数组的容器，由于元素在内存中是连续存储的，因此迭代数组元素的性能通常更好。相比之下，链表的迭代可能回涉及到更多的指针跳转，这可能回导致更多的缓存未命中和额外的开销。

总的来说，基于数组的容器在访问、迭代和内存使用方面表现更好，尤其是对于大型数据集和对性能要求较高的场景。但是，在某些特定情况下，链表可能更适合，例如需要频繁插入和删除操作，或者对内存分配和释放时间有较高的要求的情况下。

## Iterator的方法

#### `fn size_hint(&self) -> (usize, Option<usize>)`

返回迭代器剩余长度的界限

```rust
let vec = vec![1,2,3,4];
let mut iter = vec.iter();
iter.size_hint(); // (4, Some(4));
iter.next();
iter.size_hint(); // (3, Some(3));
```

#### `fn count(self)-> usize`

消耗迭代器，计算迭代器次数并返回它;

此方法将返回调用 `next`, 直到遇到 `None`,并返回它看到 `Some`的次数

```rust
let vec = vec![1,2,3];
a.iter().count() // 3
```

#### `fn last(self)-> Option<Self::Item>`

消耗迭代器，返回最后一个元素

此方法将评估迭代器，直到返回None，这样做是，它会跟踪当前元素。返回None之后，`last()`将返回它看到的最后一个元素。

```rust
let vec = vec![1,2,3];
a.iter().last() // Some(3);
```

#### `fn nth(&mut self) -> Option<Self::Item>`

返回迭代器的第n个元素，从0开始，如果n大于或者等于迭代器的个数，则 `nth()`返回None

请注意，所有先前的元素以及返回的元素都将从迭代器中消耗，这意味着前面的元素将被丢弃，并且在同一迭代器上多次调用 `nth(0)`将返回不同的元素。

```rust
let a = [1,2,3];
a.iter().nth(2) // Some(3);

// 多次调用 nth(2),不会回退迭代器，已经被消费。
```

#### `fn step_by(self, step:usize) -> StepBy<Self> where Self:Sized`

创建一个从同一个点开始的迭代器，但每次迭代时，以给定的数量逐步执行。

> 注意: 无论step是多少，每次迭代时，以给定的数量逐步运行。

该方法类似于:

```rust
fn advance_n_and_return_first<T>(&mut iter: T, n: usize) -> Option<T::Item>
where T: Iterator,
{
  let next = iter.next();
  if n>1{
    iter.nth(n-1);
  };
  next
}
```

### chain方法

```rust
fn chain<U>(self, other: U) -> Chain<Self, <U as IntoIterator>::IntoIter>
where
Self: Sized
U: IntoIterator<Item = Self::Item>,

// as方法用于将 `U` 转成 IntoIterator类型
```

接受两个迭代器，并依次在两个迭代器上创建一个新的迭代器。
`chain()`将返回两个迭代器，它首先迭代第一个迭代器的值，然后迭代第二个迭代器的值。

```rust
let a1 = [1,2,3];
let a2 = [4,5,6];

let mut iter = a1.iter().chain(a2);
```

### `zip`方法

```rust
fn zip<U>(self, other: U) -> Zip<Self, <U as IntoIterator>::IntoIter>
where
Self: Sized,
U: IntoIterator,
```

将两个迭代器压缩成为单个迭代器

`zip()`返回一个新的迭代器，它将迭代其他两个迭代器，返回一个元组。

如果任意一个迭代器返回None，则zipped迭代器中的next将返回None

```rust
let a1 = [1,2,3];
let a2 = [4,5,6];

let mut iter = a1.iter().zip(a2);
```

### `map`方法

```rust
fn map<B,F>(self, f: F) -> Map<Self, F>
where
Self: Sized,
F: FnMut(Self::Item) -> B,
```

获取一个闭包并创建一个迭代器，该迭代器在每个元素上调用该闭包。

`map()`通过器参数将一个迭代器转换为另一个迭代器：实现 `FnMut`的东西。它产生一个迭代器，在原始迭代器的每个元素上调用此闭包。

如果你有一个迭代器为您提供某种类型的A元素，并且想要的某个其他类型的B元素迭代器，则可以使用`map()`,传递一个 需要A并返回B的闭包。

```rust
let a = [1,2,3];
let mut iter = a.iter().map(|x| x*2);
```

### `for_each`方法

```rust
fn for_each(self, f:F)
where
F: FnMut(Self::Item),
```

在迭代器的每个元素上调用一个闭包

这等效于在迭代器上使用for循环，尽管不能从封闭包中获得 `break` 和 `continue`. 通常，使用 `for`循环更为习惯，但是在较长的迭代器链的末尾处理Item时， `for_each`更为容易理解。

在某些情况下， `for_each`也可能比循环更快，因为它将在`Chain`等适配器上使用内部迭代。

```rust
use std::sync::mpsc::channel;

let (tx, rx) = channel();
(0..5).map(|x| x*2).for_each(move|x|{tx.send(x).unwrap()});

let v: Vec<_> = rx.iter().collect();
assert_eq!(v, vec![1, 3, 5, 7, 9]);
```

#### `filter`方法

```rust
fn filter<P>(self, predicate: P) -> Filter<Self, P>
where
Self: Sized,
P: FnMut(&Self::Item) -> bool,
```

创建一个迭代器，该迭代器使用闭包确定是否应产生元素。

给定一个元素，闭包必须返回 `true`或 `false`.返回的迭代器仅生成为其返回 `true`的元素。

```rust
let a = [0i32, 1, 2];
let mut iter = a.iter().filter(|x| x.is_positive());
```

因为传递给 `filter()`的闭包需要一个引用，并且迭代器的元素就是一个引用，所以闭包的类型就是一个双引用:

```rust
let a = [0,1,2];
let mut iter = a.iter().filter(|x| **x > 1);

assert_eq!(iter.next(), Some(&2));
assert_eq!(iter.next(), None);
```

通常在参数上使用解构来去掉一个：

```rust
let a = [0, 1, 2];
let mut iter = a.iter().filter(|&x| *x > 1);
```

或两个:

```rust
let a = [0,1,2];
let mut iter = a.iter().filter(|&&x| x> 1);
```

请注意，**`iter.filter(f).next()`等于 `iter.find(f)`**

### `filter_map`方法

```rust
fn filter_map<B, F>(self, f: F) -> FilterMap<Self, F>
where
Self: Sized,
F: FnMut(Self::Item) -> Option<B>,
```

创建一个同时过滤和映射的迭代器。

返回的迭代器只产生`value`, 而提供的闭包回返回`Some(value)`

`filter_map`可用于使 `filter`和 `map`的链更简洁。下面的示例显示了如何将 `map().filter().map()`缩短为 `filter_map`的单个调用。

```rust
let a = ["1", "two", "NaN", "four", "5"];

let mut iter = a
    .iter()
    .filter_map(|s| s.parse::<i32>().ok())
    .collect::<Vec<i32>>();

println!("{:?}", iter);
```

用 `map+filter`

```rust
let mut iter = a.iter().map(|x| x.parse::<i32>()).filter(|x| x.is_ok()).map(|s|s.unwrap());
```

### `enumerate`方法

```rust
fn enumerate(self) -> Enumerate<Self>
where
Self: Sized,
```

创建一个迭代器，该迭代器给出当前迭代次数以及下一次值。

### `peekable`方法

```rust
fn peekable(self) ->Peekable<Self>
where
Self: Sized,
```

创建一个迭代器，它可以使用 `peek`和 `peek_mut`方法查看迭代器的下一个元素而不消耗它。

```rust
let array = [1,2,3];
let mut iter = array.iter().peekable();

assert_eq!(iter.peek(), Some(&&1));
assert_eq!(iter.next(), Some(&1));

// 多次调用 `peek()` ,迭代器不会前进
assert_eq!(iter.peek(), Some(&&2));
assert_eq!(iter.peek(), Some(&&2));
```

使用 `peek_mut`在不推进迭代器的情况下改变下一个项:

```rust
let array = [1,2,3];
let mut iter = array.iter().peekable();

assert_eq!(iter.peek_mut(), Some(&mut &1));
assert_eq!(iter.peek_mut(), Some(&mut &1));
assert_eq!(iter.next(), Some(&1));

if let Some(mut p ) = iter.peek_mut(){
  assert_eq!(*p, &2);
  *p = &2000;
}
```

### `skip_while`方法

```rust
fn skip_while<P>(self, predicate: P) -> SkipWhile<Self, P>
where
Self: Sized,
P: FnMut(&self::Item) -> bool,
```

创建一个迭代器，该迭代器基于谓词 `skip`元素

`skip_while`将闭包作为参数。它将在迭代器的每个元素上调用此闭包，并忽略元素，直到返回false。

返回 `false`后，skip_while()的工作结束，并产生元素的剩余部分。

```rust
let a = [-1i32, 0, 1];
let mut iter = a.iter().skip_while(|x| x.is_negative());

assert_eq!(iter.next(), Some(&0));
assert_eq!(iter.next(),Some(&1));
assert_eq!(iter.next(),None)
```

因为传递给 `skip_while`的闭包需要一个引用，并且许多迭代器都在引用上进行迭代，所以这会导致一种可能令人困惑的情况，其中闭包参数的类型是双引用。

```rust
let a = [-1, 0, 1];
let mut iter = a.iter().skip_while(|x| **x < 0);  // 需要两个 *s.

// 遇到 false之后，就停止 skip
```

### `take_while`方法

```rust
fn take_while<P>(self, predicate: P) -> TakeWhile<Self, P>
where
Self: Sized,
P: FnMut(&Self::Item) -> bool,
```

创建一个迭代器，根据谓词产生元素。

`take_while`将闭包作为参数。它将在迭代器的每个元素上调用此闭包，并在返回 `true`时产生 `yield`元素。

返回 `false`后， `take_while`的工作结束，并且元素的剩余部分被忽略.

```rust
let a = [-1i32, 0, 1];
let mut iter = a.iter().take_while(|x| x.is_negative());

assert_eq!(iter.next(), Some(&-1));
assert_eq!(iter.next(), None);
```

### `map_while`方法

```rust
fn map_while<B,P>(self, preducate: P) -> MapWhile<Self, P>
where

"$or": {
    "translation.name": {
        "$regex": name
    },
    "translation.key": {
         "$regex": key
     }
},
"translation.client": client,
                        "translation.lang": lang
```

## Option

用于处理引用的适配器

| 方法           | 用途                                                |
| -------------- | --------------------------------------------------- |
| `as_ref`       | 从 `&Option<T>` 转换为 `Option<&T>`                 |
| `as_mut`       | 从 `&mut Option<T>` 转换为 `Option<&mut T>`         |
| `as_deref`     | 从 `&Option<T>`转为 `Option<&T::Target>`            |
| `as_mut_deref` | 从 `&mut Option`转为 `Option<&mut T::Target>`       |
| `as_pin_ref`   | 从 `Pin<&Option<T>>`转为 `Option<Pin<&T>>`          |
| `as_pin_mut`   | 从 `Pin<&mut Option<T>>` 转为 `Option<Pin<&mut T>>` |

自定义错误演示

```rust
pub enum ParseAccountError {
    #[error("{0:?} account not parsable")]
    AccountNotParsable(ParsableAccount),

    #[error("Program not parsable")]
    ProgramNotParsable,

    #[error("Additional data required to parse: {0}")]
    AdditionalDataMissing(String),

    #[error("Instruction error")]
    InstructionError(#[from] InstructionError),

    #[error("Serde json error")]
    SerdeJsonError(#[from] serde_json::error::Error),
}
```

```rust
rust的tokio的task的重要三点:
1. 轻量级： 不需要上下文切换，低开销
2. 非抢占式：合作式
3. 非阻塞
```

### 通过 data: url 方式嵌入图像

```rust
img.src =
  "data:image/gif;base64,base64地址";
```

## 什么是零拷贝

零拷贝(Zero Copy) 是一种优化技术，用在数据传输过程中减少或者消除不必要的数据拷贝操作，从而提高性能和降低资源消耗。在传统的数据传输过程中，数据通常需要多次复制，比如从磁盘读取到内存，然后从内存复制到网络缓存区。再从缓冲区到网络接口。零拷贝技术通过最小化或完全消除这些数据拷贝操作，来提高数据传输的效率。

零拷贝技术的实现方式通常包括以下几种方法。

* 直接内存访问: 通过DMA控制器，直接将数据从设备(磁盘，网络接口)读取到内存，或者从内存写入设备，而不需要经过CPU，这样可以避免CPU参与数据拷贝的过程，提高数据传输效率。
* 内核空间和用户空间的共享内存(Shared Memery Between kernel Space and User Space):在数据传输时，内核空间和用户空间可以共享同一块内存区域，从而避免在内核空间和用户之间进行数据拷贝的过程。
* 文件描述符传递(File Descriptor Passing): 在 UNIX-like系统中，可以通过 `sendfile()`或 `splice()`等系统调用，将文件描述符从一个进程传递给另一个进程从而避免了在内核中进行数据拷贝的过程。
* 零拷贝网络传输：在网络数据传输过程中，可以使用零拷贝技术来减少或消除拷贝操作。比如，使用零拷贝技术将数据直接从应用程序缓存区传输到网络接口中，或者将接受到的数据直接传输到应用缓冲区，而不需要经过中间缓冲区。

## 什么是DMA控制器

DMA(Direct Memory Acces， 直接内存访问)控制器是计算机系统中的一种专用硬件，用于管理内存之间的数据传输，而无需CPU的直接干预。它的作用是在设备（比如磁盘、网络接口、显卡等）和内存之间直接传输数据，从而减轻CPU的负担，提高系统的效率和性能。

DMA控制器通常由硬件实现，主要组成部分包括：

* 控制逻辑：负责协调数据传输过程，包括设置传输参数，启动传输，处理传输中端等。
* 通道：用于连接设备和内存之间的数据传输路径，通常一个DMA控制器可以有多个通道，每个通道可以连接一个设备和一个内存地址。
* 内存地址寄存器：用于存储数据传输的源地址和目的地址，指示数据传输的起始位置和目标位置。
* 计数器：用于存储数据传输的数据量，指示数据传输的长度。

DMA控制器的工作原理如下：

* 当设备需要向内存中读取或者写入数据时，它会向DMA控制器发送请求。
* DMA控制器接受到请求后，根据请求的类型和参数设置通道，内存地址和计数器。
* DMA控制器启动数据传输，将数据从设备读取到内存或者从内存中写入设备。
* 数据传输完成后，DMA控制器向设备发送完成信号，并可能触发终端以通知CPU数据传输已完成。

通过使用DMA控制器，设备和内存之间的数据传输可以在不需要CPU参与的情况下完成，这样可以释放CPU的资源，提高系统的效率和性能。DMA控制器在许多计算器都得到了广泛引用。

## fetch api的Response接口

```javascript
Response() // 创建一个新的Response对象

// 属性
Response.headers // 包含此Response所关联的 `Headers`对象
Response.ok  // 包含一个布尔值， 标识该Response成功(HTTP状态码的范围在200-299)
Response.redirected // 表示该Response是否来自一个重定向，如果是的话，它的URL列表将会有多个条目
Response.status // 包含Response的状态码
Response.statusText // 包含了该Response状态码一致的状态信息(例如，OK对应200)
Response.type // 包含Response的类型(例如: basic, cors);
Response.url // 包含Response的URL
Response.body // 一个简单的getter, 用于暴露一个 `ReadableStream`类型的body内容。
Response.bodyUsed // 包含一个布尔值，来标识该Response是否读取过Body

// 方法
Response.clone() // 创建一个Response对象的克隆
Response.error()	// 返回一个绑定了网络错误的新的`Response`对象
Response.redirect() //用另一个URL创建一个新的Response
Body.arrayBuffer() // 读取 `Response`对象并且将它设置为已读（因为`Responses对象被设置为 `stream`的方式，所以它们只能被读取一次), 并返回一个呗解析为 `ArrayBuffer`格式的 `Promise`对象
Body.blob() // 读取 `Response`对象并且将它设置为已读（因为`Responses对象被设置为 `stream`的方式，所以它们只能被读取一次), 并返回一个呗解析为 `Blob`格式的 `Promise`对象

Body.formData() // 读取 `Response`对象并且将它设置为已读（因为`Responses对象被设置为 `stream`的方式，所以它们只能被读取一次), 并返回一个呗解析为 `FormData`格式的 `Promise`对象

Body.json() // 读取 `Response`对象并且将它设置为已读（因为`Responses对象被设置为 `stream`的方式，所以它们只能被读取一次), 并返回一个呗解析为 `JSON`格式的 `Promise`对象

Body.text() // // 读取 `Response`对象并且将它设置为已读（因为`Responses对象被设置为 `stream`的方式，所以它们只能被读取一次), 并返回一个呗解析为 `USVString`格式的 `Promise`对象

'application/json'
'multipart/form-data'
'application/x-www-form-urlencoded'
```

### ArrayBuffer

`ArrayBuffer`对象用来表示通用的原始二进制数据缓冲区

它是一个字节数组，不能直接操作 `ArrayBuffer`中的内容，而是要通过类型化数组对象或者 `DataView`对象来操作

### FormData

提供了一种表示表单数据的键值对`key/value`的构造方式，并且可以轻松的将数据通过 `XMLHTTPResquest.send()`发送出去。如果发送出时的编码类型被设置为 `multipart/form-data`,它会使用和表单一样的格式。

## fetch api的request接口

`Resquest`接口用来表示资源请求

```javascript
// 构造函数
Response() // 创建一个新的`Response`对象

// 实例属性
Response.body // 主体内容的 `ReadableStream`
Request.bodyUsed // 存储 `true` 或 `false`, 以指示请求是否仍然未被使用。
Request.cache // 包含请求的缓存模式(例如, default, reload, no-cache).
Request.credentials // 包含请求的凭据(例如：omit, same-origin, include). 默认是 `same-origin`
Request.destination // 返回一个描述请求的目的字符串。这是一个字符串，指示所请求的内容类型。

```

### Headers接口

`Headers`接口允许你对 `Http`请求和响应头执行各种操作。这些操作包含检索，设置，添加和删除。

一个 `Headers`对象具有关联的表头列表，它最初为空，由零个或者多个键值对组成。你可以使用类似于 `append`这样的方法添加到这个对象中。在该接口的所有方法中，标头名称不区分大小写的字节序列匹配。

```javascript
// 构造函数
Headers.Headers() // 创建一个新的`Headers`对虾

// 方法
Headers.append() // 给现有的header添加一个值，或者添加一个未存在的header并赋值。
Headers.delete() // 从 `Headers`对象中删除指定 header.
Headers.entries() // 以迭代器的形式返回 `Headers`对象中所有的键值对
Headers.get() // 以`ByteString`的形式从`Headers`对象中返回指定 `header`的全部值。
Headers.has() // 以布尔值的形式从 `Headers`对象中返回是否存在指定的 `header`.
Headers.keys() // 以迭代器的形式返回 `Headers`对象中所有存在的 `header`名。
Headers.set() // 替换现有的 `header`的值，或者添加一个未存在的header并赋值。
Headers.values() // 以迭代器的形式返回 `Headers`对象中所有存在的header的值。


// 示例。

```

## js中的 `TextDecoder` 与 `TextEncoder`,encodeURI

## js中的 Streams APi



父组件： 

```svelte
<script>
	const handleMessage = ()=>{
    ...
  }
</script>

<Inner on:message={handleMessage}></Inner>
```

子组件

```svelte
<script>
	import {createEventDispatcher} from "svelte";
  const dispatch = createEventDispatcher();
  
  function sayHello(){
    dispatch("message", {
      text: "hello"
    });
  }
</script>

<button on:click={sayHello}>Click to say Hello</button>
```

## Object和Symbol

## rust中`Cow`的意思

定义

```rust
enum Cow<a, B>
where B: ?Sized +ToOwned,
{
  Borrowed(&'a B),
  Owned(<B as ToOwned::Owned),
}
```

## tokio学习

### Features

* `rt`: `tokio::task` 模块



## Trait Objects(特征对象)

当代码涉及`多态性(polymorphism)`时，需要有一种机制(`mechanism`)来确定实际运行的具体版本。这就是所谓的 “调度(`dispatch`)”。调度有两种主要形式：静态调度(`static dispatch`)和动态调度(`dynamic dispatch`)。Rust 支持静态调度，但也通过一种称为 “特质对象(`trait objects`) ”的机制支持动态调度。

### 背景

实现一个简单的 `trait` FOO

```rust
trait Foo{
  fn method(&self) -> String;
}


impl Foo for u8{
  fn method(&self) -> String{
    format!("u8: {}", *self)
  }
}
impl Foo for String {
    fn method(&self) -> String { format!("string: {}", *self) }
}
```

### 静态调度(static dispatch)

我们可以通过特征绑定(`trait bound`)执行`static dispatch`

```rust
fn do_something<F: Foo>(x: T){
  x.method()
}

fn main(){
  let x = 100;
  let y = "Hello".to_string();
  
  do_something(x);
    do_something(y);
}
```

`Rust` 在这里使用 “单态化(`monomorphization) ”来执行静态调度。这意味着 `Rust` 将为 `u8` 和 `String` 创建一个特殊版本的 `do_something()`，然后用对这些特殊函数的调用替换。换句话说，Rust 会生成类似这样的代码：

```rust
fn do_something_u8(x: u8) {
    x.method();
}

fn do_something_string(x: String) {
    x.method();
}

fn main() {
    let x = 5u8;
    let y = "Hello".to_string();

    do_something_u8(x);
    do_something_string(y);
}
```

这样做有一个很大的好处(`upside`)：**静态调度允许函数调用内联，因为在编译时就知道了被调用者，而内联是良好优化的关键。静态调度速度很快，但也有代价：“代码膨胀”，因为二进制文件中存在许多相同函数的副本，每种类型都有一个副本。**

此外，编译器并不完美，可能会将代码 “优化 ”得更慢。例如，过于急切地内联函数会使指令缓存（缓存控制着我们周围的一切）变得臃肿。这就是 `#[inline] `和 `#[inline(always)]` 应谨慎使用的部分原因，也是使用动态分派有时更高效的原因之一。

不过，常见的情况是使用静态调度更有效率，人们总是可以使用一个静态调度封装函数来进行动态调度，但反之亦然(`but not vice versa`)，这意味着静态调用更灵活。因此，标准库尽可能使用静态调度。

### 动态调度(dynamic dispatch)

`Rust` 通过一种名为 “特质对象(`trait objects`) ”的功能提供`dynamic dispatch`。特质对象（如 `&Foo` 或 `Box<Foo>`）是一种正常值，可以存储实现给定特质的任何类型的值，而精确类型只能在运行时才能知道。

特质对象可以从实现特质的具体类型的指针中获取，方法是将其转换（如将 `&x` 转换为 `&Foo`）或强制（如将 `&x` 作为接收 `&Foo` 的函数的参数）。

这些特质对象的强制和转换也适用于指针，如从 `&mut T` 到 `&mut Foo`，从 `Box<T>` 到 `Box<Foo>`，但目前仅此而已。强制和转换是相同的。

这种操作可以看作是 “抹除 ”编译器对指针特定类型的了解，因此特质对象有时被称为 “类型抹除”。

回到上面的例子，我们可以使用相同的特质，通过施转对特质对象执行动态调度：

```rust
fn do_something(x: &Foo){
  x.method()
}

fn main(){
  let x = 5u8;
  do_something(&x as &dyn Foo);
}
```

获取 `trait` 对象的函数不会专门用于实现 Foo 的每种类型：**只会生成一个副本，这通常（但不总是）会减少代码的臃肿。然而，这样做的代价是需要更慢的虚拟函数调用，并有效地抑制了内联和相关优化的机会。**

### 为什么是指针

`Rust` 与许多托管语言不同，默认情况下不会将事物放在指针后面，因此类型可以有不同的大小。在编译时知道值的大小，对于将值作为参数传递给函数、在堆栈中移动值以及在堆上分配（和取消分配）空间来存储值等事情都很重要。

对于 `Foo`，我们需要一个至少可以是字符串（`24` 字节）或 u8（`1` 字节）的值，以及任何其他依赖板块可以实现 `Foo` 的类型（任何字节数）。如果不使用指针存储值，就无法保证最后一点有效，因为其他类型的值可以非常大。

将值放在指针后面意味着当我们抛掷特质对象时，值的大小与我们无关，我们只关心指针本身的大小。

### 表现(`reapresentation`)

`trait`的方法可以通过传统上称为 “vtable”（由编译器创建和管理）的特殊函数指针记录在特质对象上调用。

特质对象既简单又复杂：它们的核心表示法和布局非常简单，但也有一些卷曲的错误信息和令人惊讶的行为。

让我们从特质对象的运行时表示说起。std::raw 模块包含结构体，其布局与复杂的内置类型（包括特质对象）相同：

```rust
pub struct TraitObject{
    pub data: *mut(),
    pub vtable: *mut()
}
```

也就是说，像 `&Foo` 这样的特质对象由一个 “数据 ”指针和一个 `“vtable ”`指针组成。

数据指针指向特质对象存储的数据（未知类型 T），而 vtable 指针指向与 Foo 对 T 的实现（“虚拟方法表”）。

vtable 本质上是一个函数指针结构，指向实现中每个方法的具体机器代码。像 trait_object.method() 这样的方法调用将从 vtable 中获取正确的指针，然后对其进行动态调用。例如

```rust
struct FooVtable {
    destructor: fn(*mut ()),
    size: usize,
    align: usize,
    method: fn(*const ()) -> String,
}

// u8:

fn call_method_on_u8(x: *const ()) -> String {
    // the compiler guarantees that this function is only called
    // with `x` pointing to a u8
    let byte: &u8 = unsafe { &*(x as *const u8) };

    byte.method()
}

static Foo_for_u8_vtable: FooVtable = FooVtable {
    destructor: /* compiler magic */,
    size: 1,
    align: 1,

    // cast to a function pointer
    method: call_method_on_u8 as fn(*const ()) -> String,
};


// String:

fn call_method_on_String(x: *const ()) -> String {
    // the compiler guarantees that this function is only called
    // with `x` pointing to a String
    let string: &String = unsafe { &*(x as *const String) };

    string.method()
}

static Foo_for_String_vtable: FooVtable = FooVtable {
    destructor: /* compiler magic */,
    // values for a 64-bit computer, halve them for 32-bit ones
    size: 24,
    align: 8,

    method: call_method_on_String as fn(*const ()) -> String,
};
```

每个 `vtable` 中的析构函数字段都指向一个函数，该函数将清理该 vtable 类型的任何资源：对于 `u8` 来说，这是微不足道的，但对于 `String` 来说，它将释放内存。这对于 `Box<Foo> `等拥有特质的对象来说是必要的，因为当这些对象退出作用域时，需要同时清理 `Box` 分配和内部类型。`size` 和 `align` 字段存储了被擦除类型的大小及其对齐要求；由于这些信息被嵌入到析构函数中，所以目前基本上还未使用，但随着特质对象逐渐变得更加灵活，将来会用到这些信息。

假设我们有一些实现 `Foo` 的值。`Foo` 特质对象的构造和使用的显式形式可能是这样的（忽略类型错配：反正它们都是指针）：

```rust
let a: String = "foo".to_string();
let x: u8 = 1;

// let b: &Foo = &a;
let b = TraitObject {
    // store the data
    data: &a,
    // store the methods
    vtable: &Foo_for_String_vtable
};

// let y: &Foo = x;
let y = TraitObject {
    // store the data
    data: &x,
    // store the methods
    vtable: &Foo_for_u8_vtable
};

// b.method();
(b.vtable.method)(b.data);

// y.method();
(y.vtable.method)(y.data);
```

### 对象安全(`Object Safity`)

不是所有的`trait`都可以被用作`trait object`, 比如：`vectors`实现了 `Clone`,但是当我们尝试去用 `Clone`去做一个特征对象时:

```rust
let v = vec![1,2,3];
let o = &v as &Clone;
```

我们得到一个错误:

```rust
error: cannot convert to a trait object because trait `core::clone::Clone` is not object-safe [E0038]
let o = &v as &Clone;
        ^~
note: the trait cannot require that `Self : Sized`
let o = &v as &Clone;
```

该错误说明克隆不是 `“对象安全 ”`的。只有对象安全的特质才能成为特质对象。如果以下两个条件都为真，那么特质就是 `“对象安全 ”`的：

* 该特质不要求 `Self: Sized`的
* 所有方法都是对象安全的

那么是什么让一个方法成为对象安全的呢？每个方法都必须符合 Self: Sized 或以下所有条件：

* 必须没有任何类型参数(范型之类的)
* 不得使用 `Self`

我们可以看到，几乎所有这些规则都在谈论 `Self`。一个很好的直觉是 “除非在特殊情况下，如果你的特质方法使用了 `Self`，那么它就不是对象安全的”。

## `Unicode`和 `UTF-8`的区别

* `Unicode`是一个字符编码标准，旨在为所有可能的字符和符号分配唯一的数字代码。是一个字符集，定义了字符与代码点(code point)之间的映射
* `UTF-8`是一种`Unicode`的编码方式，是`Unicode`字符编码标准的一部分，它描述了如何将`Unicode`代码点(抽象的字符)转换为一系列字节，用于存储和传输。
  * 编码形式： `UTF-8`采用一到4个字节来编排每个`Unicode`字符。它是一种可变长的



## rust的Future

`future`表示通过使用 `async` 获得的异步计算(`asynchronous computation`)。
`future`值是一个可能尚未完成计算的值。这种 “异步值 ”可以让线程在等待该值可用时继续执行有用的工作。
`poll method`(轮询方法)
`future` 的核心方法`pool`会尝试将 `future` 分解为最终值。如果值尚未就绪，该方法不会阻塞。相反，当前任务会被唤醒，以便通过再次轮询取得进一步进展。传递给 `poll` 方法的上下文可以提供一个 `Waker`，它是唤醒当前任务的句柄。
使用 `future` 时，一般不会直接调用 `poll`，而是 `.await `值。



```rust
diagnostic // adj. 诊断的；特征的
coalesce // v. 合并；联合；接合
reentrant // adj. 重新进入的
persistent //adj. 坚持的；连续的；巩固的
periodically // adv. 周期性的；定期的
replication // n. 复制
```

## python中使用范型

```python
from typing import TypeVar
T = TypeVar('T')  # Can be anything
A = TypeVar('A', str, bytes)  # Must be str or bytes
```

## rust中的shebang的意思

在`Rust`中，`shebang`指的是在脚本文件的第一行使用 `#![shebang]`指令，以指定解释器来运行脚本文件。`Shebang`是一个 `Unix`术语，起源于脚本文件，例如 `shell`脚本。它允许直接从命令行运行脚本文件，而无需明确调用解释器.

```rust
#! /usr/bin/env rustx

fn main(){
  println!("Hello!");
}
```

## rust中的`identifier`

标识符(`identifier`)用于**命名变量、函数、类型**等。理解标识符的定义及其细微差别对于编写合法且可读的Rust代码是非常重要的。

**标识符的定义和分类**

* `IDENTIFIER_OR_KEYWORD`: 这是一种标识符或者关键字，它有两种形式:
  * 1. 普通标识符： 以`XID_Start`字符开头，后面跟零个或多个`XID_Continue`字符。(`XID_Start`和 `XID_Continue`是Unicode定义的一类字符，用于标识符的开始和继续部分。)
    2. 下划线开头的标识符：以下划线`_`开头，后面跟一个或多个`XID_Continue`字符。

* `RAW_IDENTIFIER`： 原始标识符以`r#`开头，后跟`IDENTIFIER_OR_KEzzyWORD`, 但是不能是 `crate`, `self`, 例如 `r#foo`, `r#march`.
* `NON_KEYWORD_IDENTIFIER`: 非关键字标识符是`IDENTIFIER_OR_KEYWORD`,但不能是RUST的严格或者保留关键字。例如: `foo`,`bar`.

## rust中的`XID_Start`是什么

在rust编程语言的标识符定义中，`XID_Start`和 `XID_Continue`是两个`Unicode`字符属性，定义了一组可以用于标识符的字符。他们来源与Unicode标准，广泛用于编程语言，正则表达式等领域，确保标识符能支持多种语言的字符。

**`XID_Start`和 `XID_Continue`**

* `XID_Start`: 属性包含了可以作为标识符开始的字符。这些字符一般包括:
  * 所有的字母(大写和小写，中文等)
  * 所有一些可以作为标识符开头的字符，例如下划线(`_`)
* `XID_Continue`:
  * 所有的字符(大写和小写)
  * 所有的数字(0-9)
  * 连接符(例如，下划线`_`)
  * 某些标点符号(`_$)

## `OuterAttribute`和 `InnerAttribute`的含义

在rust中，属性(`attributes`)用于提供元数据或者修饰代码的行为。`Rust`属性可以出现在多个地方，例如模块、函数、结构体、枚举等。根据属性的位置，他们可以分为外部属性(`OuterAttribute`)和内部属性(`InnerAttribute`).

### `OuterAttribute`(外部属性)

外部属性放置在所修饰的项(`item`)之前，使用`#`符号。它们适用于项的整体，而不是项内部的某个部分。例如：外部属性可以用于模块、函数、结构体等。

语法形式:

```rust
#[attribute_name]
```

示例

```rust
#[derive(Debug)]
struct MyStruct{
  field: i32,
}

#[inline]
fn my_function(){
  
}
```

### `Inner Attribute`(内部属性)

内部属性放置在项的内部，使用`#!`符号。它们通常对于整个模块或者整个`crate`生效的属性。

语法形式:

```rust
#![attribute_name]
```

```rust
#![allow(unused_variables)]

fn main() {
    #![allow(dead_code)]
    
    fn unused_function() {
        // Function body
    }
    
    let unused_variable = 42;
}
```

`#![allow(unused_variables)]` 是一个内部属性，作用范围是整个 crate（或者模块）。

`#![allow(dead_code)]` 是一个内部属性，作用范围是 `main` 函数内部。

## 二进制文件中的数据为什么在rust中可以用`u8`表示

二进制文件中的数据用`u8`表示，这是因为`u8`是一个8位的无符号整数类型，表示从0到255的整数。每个字节(byte)都是由8个二进制位(bit)组成的，能够表示256种不同的值，正好对应`u8`类型的取值范围。因此，`u8`可以表示任何单个字节的数据。

## rust中字符(`char`)和字节(`u8`)的区别

**字符(`char`)**

* Rust中的`char`类型表示一个`Unicode`标量值，可以表示任何有效的Unicode字符。
* 每个`char`占用4个字节(32位)
* 使用场景： 用于处理需要表示单个`Unicode`字符的情况，例如字母、标点符号、汉子等。

**字节(`u8`)**

* Rust中的`u8`类型表示一个8位的无符号整数，即一个字节。
* 每个`u8`占用一个字节(8位)
* 范围: 可以表示从`0`到`255`的值。
* 使用场景：用于处理原始的字节数据，例如文件的读取、网络数据传输等。

**字符和字节之间的转换**

字符转换成字节

一个复杂点的字符转换成字节需要4个字节

```rust
fn main() {
    let a = '😊';
    let b = a.to_string().as_bytes().len();
    print!("{b}");
    // output: 4
}
```

字节转换成字符

从字节转换回字符通常需要知道字节的编码方式，如`UTF-8`

```rust
fn main() {
    let bytes = [65,66,67];
    let str = std::str::from_utf8(&bytes);
    println!("{:?}",str);
}
```

## rust中`String`是如何存储`char`的

1. 每个 `char`调用其方法`len_utf8()`来确定`UTF-8`表示的字节数
2. 使用 `encode_utf8()`方法将`char`转换为 `UTF_8`字符串。

## rust中`byte string literal` 和 `string literal`的区别

**`string literal`**

* **语法**：用双引号包围，例如 `"Hello, world!"`。

* 类型: `&str`, 一个字符串切片
* 内容：存储的是 `UTF-8`编码的字符串
* 使用场景： 适用于需要处理`Unicode`字符串的场景，例如常见的文本处理。
* 特点: 
  * 支持所有合法的 `Unicode`字符。
  * 可以包含转义序列，例如 `\n`表示换行，`\t`表示制表符

**`byte string literal`**

* 语法： 用前缀`b`和双引号包围，例如:`b"hello,world"`.
* 类型: `&[u8]`,一个字节数组切片。
* 内容：存储的是字节数组，每个元素都是一个字节 `u8`
* 使用场景： 适用于需要处理原始字节数据的场景，例如二进制文件处理或网络协议实现。



## rust中的`literal`是什么

在rust中，`literal`是指源代码中直接写出的固定值。 `Literal`在编译时被直接解析成响应的数据类型。这些固定值通常包括整数、浮点数、字符、字符串、布尔值等。



## rust中的 `no_link`属性

作用是告诉编译器不要将这个外部库链接到最终生成的可执行文件或库中

* 这个属性通常用于仅需要访问外部库的宏定义，而不需要该库的其他部分。
* 例如，如果你需要一个外部库中的宏来简化代码生成或其他编译时的任务，可以使用 `no_link`来避免不比需要的链接，从而减少生成的二进制文件大小

不会被链接到输出，可以使用该库的宏。



## js正则表达式的标准写法

```rust
regexp = new **RegExp**(**pattern**[, **flag**]);

**pattern**: 模板的用法是关键，也是本章的主要内容。
  **flag**:   "i"(ignore)、"g"(global)、"m"(multiline)的组合
  i-忽略大小写，g-反复检索，m-多行检索   flag中没有g时，返回字符串，有g时返回字符串数组



设置了g修饰符的正则表达式在完成一次成功匹配后不会停止，而是继续找到所有可以匹配到的字符。
```

